---
title: java常见面试题
mathjax: true
date: 2018-03-15 10:40:55
tags: [java]
category: [工作]
---

#### 1. 面向对象特征

<!--more-->

封装，继承，多态和抽象

1. 封装
   封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改
   变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符
   给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
   下面列出了使用封装的一些好处：
   - 通过隐藏对象的属性来保护对象内部的状态。
   - 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。
   - 禁止对象之间的不良交互提高模块化
2. 继承：给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。
3. 多态：是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
4. 抽象：是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。

#### 2. final, finally, finalize 的区别

1. final修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。
2. finally在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。
3. finalize方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

#### 3. int 和 Integer 有什么区别

int 是基本数据类型
Integer是其包装类，注意是一个类。

java包含8个基本类型：byte（字节型）、short（短整型）、int（整型）、long（长整型）、float（单精度浮点型）、double（双精度浮点型）、boolean（布尔型）、char（字符型）

为什么要提供包装类呢？？？
一是为了在各种类型间转化，通过各种方法的调用。否则 你无法直接通过变量转化。
比如，现在int要转为String

```java
int a=0;
String result=Integer.toString(a);
```

在java中包装类，比较多的用途是用在于各种数据类型的转化中。

```java
int num=Integer.valueOf("12");// 返回包装类型
int num2=Integer.parseInt("12"); //返回基本数据类型
```

再举例下。比如我现在要用泛型

```java
List<Integer> nums;
```

这里<>需要类。如果你用int。它会报错的。

#### 4. 重载和重写的区别

**override（重写）**

1. 方法名、参数、返回值相同。

2. 子类方法不能缩小父类方法的访问权限。

3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。

4. 存在于父类和子类之间。

5. 方法被定义为final不能被重写。

**overload（重载）**

1. 参数类型、个数、顺序至少有一个不相同。

2. 不能重载只有返回值不同的方法名。

3. 存在于父类和子类、同类中。

#### 5. 抽象类和接口有什么区别

总结：接口没有私有变量，接口可以用于实现多继承，实现接口必须实现所有其中定义的方法

接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，
另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。
还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。

#### 6. 说说反射的用途及实现

Java 反射机制在程序**运行时**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 **动态的获取信息** 以及 **动态调用对象的方法** 的功能称为 **java 的反射机制**。

Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架

Java反射的主要功能：

- 确定一个对象的类
- 取出类的modifiers,数据成员,方法,构造器,和超类.
- 找出某个接口里定义的常量和方法说明.
- 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).
- 取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.
- 在运行时刻调用动态对象的方法.
- 创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.

反射的应用很多，很多框架都有用到

spring 的 ioc/di 也是反射….
javaBean和jsp之间调用也是反射….
struts的 FormBean 和页面之间…也是通过反射调用….
JDBC 的 classForName()也是反射…..
hibernate的 find(Class clazz) 也是反射….

反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣。怎么使用使你的系统达到最优就看你系统架构和综合使用问题啦，这里就不多说了。

#### 7. HTTP 请求的 GET 与 POST 方式的区别

GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。

POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。

具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案

#### 8.cookie 和session 的区别：

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
   将登陆信息等重要信息存放为SESSION
   其他信息如果需要保留，可以放在COOKIE中

#### JDBC 流程

**1、 加载JDBC驱动程序：**
在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），
这通过java.lang.Class类的静态方法forName(String className)实现。

**2、 提供JDBC连接的URL**

- 连接URL定义了连接数据库时的协议、子协议、数据源标识。
- 书写形式：协议：子协议：数据源标识

协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。
数据源标识：标记找到数据库来源的地址与连接端口。

**3、创建数据库的连接**

- 要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。
- 使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。

**4、 创建一个Statement**

要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：
1、执行静态SQL语句。通常通过Statement实例实现。
2、执行动态SQL语句。通常通过PreparedStatement实例实现。
3、执行数据库存储过程。通常通过CallableStatement实例实现。

**5、执行SQL语句**
Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute
1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。
2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等
3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码：

**6、处理结果**
两种情况：
1、执行更新返回的是本次操作影响到的记录数。
2、执行查询返回的结果是一个ResultSet对象。

**7、关闭JDBC对象**
操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反：
1、关闭记录集
2、关闭声明
3、关闭连接对象

#### MVC 设计思想

MVC就是
M:Model 模型
V:View 视图
C:Controller 控制器
模型就是封装业务逻辑和数据的一个一个的模块,控制器就是调用这些模块的(java中通常是用Servlet来实现,框架的话很多是用Struts2来实现这一层),视图就主要是你看到的,比如JSP等.
当用户发出请求的时候,控制器根据请求来选择要处理的业务逻辑和要选择的数据,再返回去把结果输出到视图层,这里可能是进行重定向或转发等.

#### equals 与 == 的区别

值类型（int,char,long,boolean等）都是用==判断相等性。对象引用的话，==判断引用所指的对象是否是同一个。

equals是Object的成员函数，有些类会覆盖（override）这个方法，用于判断对象的等价性。例如String类，两个引用所指向的String都是”abc”，但可能出现他们实际对应的对象并不是同一个（和jvm实现方式有关），因此用==判断他们可能不相等，但用equals判断一定是相等的。

### 集合

#### List 和 Set 区别

List,Set都是继承自Collection接口

List特点：元素有放入顺序，元素可重复

Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉

（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）

Set和List对比：

Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。

List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。

#### List 和 Map 区别

List是对象集合，允许对象重复。

Map是键值对的集合，不允许key重复。

#### Arraylist 与 LinkedList 区别

**Arraylist**：

优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。

缺点：因为地址连续， ArrayList要移动数据，所以插入和删除操作效率比较低。

**LinkedList**：

优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景

缺点：因为LinkedList要移动指针,所以查询操作性能比较低。

**适用场景分析：**

当需要对数据进行顺序访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。

#### ArrayList 与 Vector 区别

ArrayList和Vector都是用数组实现的，主要有这么三个区别：

1. Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；
2. 两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。
3. Vector可以设置增长因子，而ArrayList不可以。
4. Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。

**适用场景分析**：

1. Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。
2. 如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。

#### HashMap 和 Hashtable 的区别

1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。

2.hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。

3.hashMap允许空键值，而hashTable不允许。

注意：TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。

Treemap：适用于按自然顺序或自定义顺序遍历键(key)。

#### HashSet 和 HashMap 区别

set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。

map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。

他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象

#### HashMap 和 ConcurrentHashMap 的区别

ConcurrentHashMap是线程安全的HashMap的实现。

（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。

（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。

#### ConcurrentHashMap 的工作原理及代码实现

HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。

ConcurrentHashMap引入了分割(Segment)，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。

### 线程

#### 创建线程的方式及实现

Java中创建线程主要有三种方式：

**一、继承Thread类创建线程类**

（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。

（2）创建Thread子类的实例，即创建了线程对象。

（3）调用线程对象的start()方法来启动该线程。

**二、通过Runnable接口创建线程类**

（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

（3）调用线程对象的start()方法来启动该线程。

**三、通过Callable和FutureTask创建线程**

（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。

（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

**创建线程的三种方式的对比**

采用实现Runnable、Callable接口的方式创见多线程时，优势是：

线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

劣势是：

编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

使用继承Thread类的方式创建多线程时优势是：

编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

劣势是：

线程类已经继承了Thread类，所以不能再继承其他父类。

#### sleep() 、join（）、yield（）有什么区别

**1、sleep()方法**

在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常

比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

**2、yield()方法**

yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。

**线程的sleep()方法和yield()方法有什么区别？**

答：

① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；

③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； 

④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

**3、join()方法**

Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。

#### 讲讲线程池的实现原理

主要是ThreadPoolExecutor的实现原理，在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

#### 线程池的几种方式

newFixedThreadPool(int nThreads)
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程

newCachedThreadPool()
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制

newSingleThreadExecutor()
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行

newScheduledThreadPool(int corePoolSize)
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

#### 线程的生命周期

新建(New)、就绪（Runnable）、运行（Running）、 阻塞(Blocked)和死亡(Dead)5种状态

(1)生命周期的五种状态

**新建（new Thread）**
当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
例如：Thread t1=new Thread();

**就绪（runnable）**
线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();

**运行（running）**
线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。

**死亡（dead）**
当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。

自然终止：正常运行run()方法后终止

异常终止：调用stop()方法让一个线程终止运行

**堵塞（blocked）**
由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。

正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。

正在等待：调用wait()方法。（调用motify()方法回到就绪状态）

被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）

### 锁机制

#### 说说线程安全问题

线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。
在Java里，线程安全一般体现在两个方面：
1、多个thread对同一个java实例的访问（read和modify）不会相互干扰。

它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。
2、每个线程都有自己的字段，而不会在多个线程之间共享。

它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。

#### 悲观锁 乐观锁

乐观锁 悲观锁是一种思想。可以用在很多方面。

比如数据库方面。
悲观锁就是for update（锁定查询的行）
乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）

JDK方面：
悲观锁就是sync
乐观锁就是原子类（内部使用CAS实现）

本质来说，就是悲观锁认为总会有人抢我的。乐观锁就认为，基本没人抢。

#### CAS 乐观锁

乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。

#### ABA 问题

ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS操作无法分辨当前V值是否发生过变化。

乐观锁（Optimistic Lock）：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。

乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

#### 1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。

 Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。

 Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

#### 2.JDK和JRE的区别是什么？

JDK: java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器)

JRE: java运行环境,包含java虚拟机和java程序所需的核心类库。

如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。

#### 3."static"关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？

如果一个类的变量或者方法前面有**static**修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用

 当父类的方法被**private**修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该“覆盖方法”，会产生编译错误。

static方法也是不能覆盖的，就算覆盖了父类的static方法，也没有多态的效果，因此不算是覆盖。

#### 4.Java支持的基本数据类型有哪些？什么是自动拆装箱？

java支持的基本数据类型有以下9种:byte,shot,int,long,float,double,char,boolean,void.

自动拆装箱是java从jdk1.5引用，目的是将原始类型自动的装换为相对应的对象，也可以逆向进行，即拆箱。这也体现java中一切皆对象的宗旨。

所谓自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。java中的自动拆装箱通常发生在变量赋值的过程中。

#### 5. 重写和重载是什么?

**重写**，发生在子类与父类之间，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。

**重载**是指在一个类中，可以有多个相同名称的方法，但是他们的参数列表的个数或类型不同，当调用该方法时，根据传递的参数类型调用对应参数列表的方法。当参数列表相同但返回值不同时，将会出现编译错误，这并不是重载，因为jvm无法根据返回值类型来判断应该调用哪个方法。

#### 6.Java支持多继承么？如果不支持，如何实现?
在java中是单继承的，也就是说一个类只能继承一个父类。

java中实现多继承有两种方式,一是接口，而是内部类.

### 7.什么是值传递和引用传递？java中是值传递还是引用传递，还是都有?

**值传递** 就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参，常见的例子就是刚开始学习c语言的时候那个交换方法的例子了。

**引用传递** 是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。

在java中只有值传递。

#### 8.接口和抽象类的区别是什么?

区别：

1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。

2. 类可以实现很多个接口，但是只能继承一个抽象类

3. 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

4. 抽象类可以在不提供接口方法实现的情况下实现接口。

5. Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。

6. Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。

7. 接口是绝对抽象的，不可以被实例化(java 8已支持在接口中实现默认的方法)。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。

####9.构造器（constructor）是否可被重写（override）?
构造方法不能被子类继承，所以是不能被子类重写的，但是构造方法可以重载，也就是说一个类可以有多个构造方法。

#### 10.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?
Math.round(11.5)==12 Math.round(-11.5)==-11 round 方法返回与参数 最接近的长整数，参数加 1/2 后求其 floor.

#### 11. String, StringBuffer StringBuilder的区别。

String 的长度是不可变的；

StringBuffer的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer，如果最后需要 >String，那么使用 StringBuffer 的 toString() 方法；线程安全；

StringBuilder 是从 JDK 5 开始，为StringBuffer该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步（线程不安全），所以速度更快。

使用字符串的时候要特别小心，如果对一个字符串要经常改变的话，就一定不要用String,否则会创建许多无用的对象出来.

#### 12.JVM内存分哪几个区，每个区的作用是什么?
java虚拟机主要分为以下五个区: 方虚本程堆

**方法区：**

1. 有时候也称为**永久代**，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载
2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
3. 该区域是被线程共享的。
4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

**虚拟机栈:**

1. 虚拟机栈也就是我们平常所称的**栈内存**,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
2. 虚拟机栈是线程私有的，它的生命周期与线程相同。
3. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定
4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式
5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。

**本地方法栈**

本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务。

**堆**

 java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

**程序计数器**

内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何out of memory情况的区域。

### 13.如和判断一个对象是否存活?(或者GC对象的判定方法)

判断一个对象是否存活有两种方法:

 **引用计数法**

所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.

引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

2.**可达性算法**(引用链法)

该算法的思想是：从一个被称为**GC Roots**的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

在java中可以作为GC Roots的对象有以下几种:

虚拟机栈中引用的对象
方法区类静态属性引用的对象
方法区常量池引用的对象
本地方法栈JNI引用的对象

### 14.简述java垃圾回收机制?

在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

### 15.java中垃圾回收的方法有哪些?

 1. **标记-清除:**

     这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。

 2. **复制算法:**

     为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。

     于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)

 3. **标记-整理**

     该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候先将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

4. **分代收集** 

     现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用**复制**算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用**标记-整理** 或者 **标记-清除**。

#### 16.java内存模型

java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：

#### 17.java类加载过程?

 java类加载需要经历以下5个过程：加验准解初

**加载（通过名字获取类并生成class文件），**

**验证（保证字节流不危害到虚拟机），**

**准备（为静态变量分配内存），**

**解析（符号引用变为直接引用），**

**初始化（之前的都由虚拟机控制，这一步才真正执行类中的java代码）**

 **加载**

 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：

 1. 通过一个类的全限定名获取该类的二进制流。
   
 2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
 3. 在内存中生成该类的Class对象，作为该类的数据访问入口。

 **验证**

验证的目的是为了确保Class文件的字节流中的信息不会危害到虚拟机.在该阶段主要完成以下四钟验证:

 1. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
   
 2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
   
 3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
   
 4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

 **准备**

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

**解析** 

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

**初始化**

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

#### 18.简述java类加载机制?
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

####19.类加载器双亲委派模型机制？
当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

#### 20.什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。

3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

#### **21.简述java内存分配与回收策率以及Minor GC和Major GC**

1. 对象优先在堆的Eden区分配。

2. 大对象直接进入老年代.

3. 长期存活的对象将直接进入老年代.



当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。

**Minor GC条件**

当Eden区空间不足以继续分配对象，发起Minor GC。

**Full GC条件**

1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）
3. 方法区空间不足






### **22.HashMap的工作原理是什么?**

HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(jdk 8为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。HashMap是基于hashing实现的，当我们进行put操作时，根据传递的key值得到它的hashcode，然后再用这个hashcode与数组的长度进行模运算，得到一个int值，就是Entry要存储在数组的位置（下标）；当通过get方法获取指定key的值时，会根据这个key算出它的hash值（数组下标），根据这个hash值获取数组下标对应的Entry，然后判断Entry里的key，hash值或者通过equals()比较是否与要查找的相同，如果相同，返回value，否则的话，遍历该链表（有可能就只有一个Entry，此时直接返回null），直到找到为止，否则返回null。

HashMap之所以在每个数组元素存储的是一个链表，是为了解决hash冲突问题，当两个对象的hash值相等时，那么一个位置肯定是放不下两个值的，于是hashmap采用链表来解决这种冲突，hash值相等的两个元素会形成一个链表。

### **23.HashMap与HashTable的区别是什么?**

1. HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现，它以最大限度地减少实现此接口所需的工作。

2. HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException。

3. Hashtable是同步的，而HashMap是非同步的，但是我们也可以通过Collections.synchronizedMap(hashMap),使其实现同步。

### 24.CorrentHashMap的工作原理?

**jdk 1.6版:** ConcurrenHashMap可以说是HashMap的升级版，ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。

具体实现:ConcurrentHashMap内部有一个Segment<K,V>数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry<K,V>数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。

 每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。

 **jdk 1.8版** 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表->红黑树”的实现。

### 27.Array和ArrayList有何区别？什么时候更适合用Array？

1. Array可以容纳基本类型和对象，而ArrayList只能容纳对象。

2. Array是指定大小的，而ArrayList大小是固定的

### 28.哪些集合类提供对元素的随机访问？

ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。

### 29.HashSet的底层实现是什么?

通过看源码知道HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。

### 30.LinkedHashMap的实现原理?

LinkedHashMap也是基于HashMap实现的，他继承自HashMap，不同的是其讲hashmap的每个元素加了一个before和after指针，由此组成了一个双向链表。TreeMap也是有序的map容器，红黑树的插入删除访问时间复杂度为O(logn)，是按照key的排序方式排序的（通过comparotor进行排序的，可以自定义）。

### 33.Thread 类中的start() 和 run() 方法有什么区别？

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

### 35.Java中有哪几种锁?

**自旋锁:** 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。

在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定

**偏向锁:** 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。

**轻量级锁:** 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

### 37.ThreadLocal理解

ThreadLocal是一个创建——线程局部变量的类。通常情况下我们创建的变量,可以被多个线程访问并修改，通过ThreadLocal创建的变量只能被当前线程访问。

**ThreadLocal内部实现**

ThreadLocal提供了set和get方法.
 set方法会先获取当前线程,然后用当前线程作为句柄,获取ThreadLocalMap对象,并判断该对象是否为空,如果为空则创建一个,并设置值,不为空则直接设置值。

#### 38. synchronized和lock的区别？

- 主要相同点：Lock能完成synchronized所实现的所有功能。
- 主要不同点：Lock有比synchronized更精确的线程予以和更好的性能。

1. synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。
2. synchronized修饰方法时,表示同一个对象在不同的线程中,表现为同步队列,如果实例化不同的对象,那么synchronized就不会出现同步效果了。

具体用法：

```java
Lock lock = new ReentrantLock
if(lock.trylock){
try{
xxxx
}
catch(Exception e){
e.printStackTrace()
}
finally{
lock.unlock();
}
}
```



#### 39. 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 

#### 40.数据库的四种隔离等级

* 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据

* 提交读(Read Committed)：写禁止读写，只限制同一数据写事务禁止其它读写事务。解决”脏读”和”更新丢失”。Oracle等多数数据库默认都是该级别 (不重复读)

* 可重复读(Repeated Read)：读写禁止其它读写。限制同一数据写事务禁止其他读写事务，读事务禁止其它写事务(允许读)。InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读

* 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

**① 脏读:** 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

**②不可重复读**：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。

**④ 幻读:**事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 （和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）

#### 倒排索引

#### 是否可以在static环境中访问非static变量？

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

#### Java支持的数据类型有哪些？什么是自动拆装箱？

Java语言支持的8种基本数据类型是：

byte、short、int、long、float、double、boolean、char

自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。

#### 概括的解释下线程的几种可用状态。线程状态

1. 新建
2. 可运行：新建后调用了start方法，放入线程池等待调度，获取cpu使用权
3. 运行：可运行的线程获取了cpu时间片
4. 阻塞：线程因某种原因放弃了cpu时间片
   1）同步阻塞：因为没有获取到同步锁而阻塞
   2）等待阻塞：调用了wait方法，等待notify方法解出阻塞状态
   3）其他阻塞：sleep方法之类的，等sleep超时之后恢复
5. 死亡：run结束，或异常退出run，死亡不可再生

#### 线程状态之间的关系

new一个线程之后，处于新建状态，调用start之后，处于可运行状态，获得cpu之后处于运行状态，调用wait，sleep，join之后处于阻塞状态，解出阻塞之后变为可运行状态，运行态调用yield处于可运行状态，运行中结束或异常处于死亡状态。

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190331160617.png)

#### 同步方法和同步代码块的区别是什么？

同步方法默认用this或者当前类class对象作为锁；

同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；

同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用   synchronized（object）{代码内容}进行修饰；

#### 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

#### 什么是死锁(deadlock)？

**死锁** **:**是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种**互相等待**的现象,若无**外力**作用,它们都将无法推进下去

（1） **互斥条件**：一个资源每次只能被一个进程使用。  

（2） **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  

（3） **不可抢占**:进程已获得的资源，在末使用完之前，不能强行剥夺。  

（4） **循环等待**:有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

#### 如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

#### 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

一：快速失败（fail—fast）

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。

原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

​      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

​    二：安全失败（fail—safe）

​      采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

​      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

​      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

​          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

####数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？

1. Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
2. Array大小是固定的，ArrayList的大小是动态变化的。
3. ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
   对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。

#### 什么是优先级队列

优先级队列就是可以排序的队列，必须继承comparator接口，使插入队列的对象是可以比较的。但是优先队列PriorityQueue是线程不安全的，concurrent包下面有线程安全的实现方式，是PriorityBlockingQueue

#### 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

#### 数据库四个特性

1. 原子性（Atomicity）

　　原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。

　　回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. 一致性（Consistency）

　　事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。

3. 隔离性（Isolation）

　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

　　即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

4. 持久性（Durability）

　　一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

　　可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

#### 什么情况下不推荐使用索引？

1) 数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引

> 比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。

2）频繁更新的字段不要使用索引

> 比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。

3) 字段不在where语句出现时不要添加索引,如果where后含IS NULL /IS NOT NULL/ like ‘%输入符%’等条件，不建议使用索引

> 只有在where语句出现，mysql才会去使用索引

4） where 子句里对索引列使用不等于（<>），使用索引效果一般

#### IOC和AOP
**IOC（DI）**

控制反转：原来是自己主动去new一个对象去用，现在是由容器工具配置文件创建实例让自己用，	说白了就是用面向接口编程和配置文件减少对象间的耦合，同时解决硬编码的问题（XML）

依赖注入：在运行过程中当你需要这个对象才给你实例化并注入其中，不需要管什么时候注入的，只需要写好成员变量和set方法

**AOP**

介绍

面向切面的编程，是一种编程技术，是OOP（面向对象编程）的补充和完善。OOP的执行是一种从上往下的流程，并没有从左到右的关系。因此在OOP编程中，会有大量的重复代码。而AOP则是将这些与业务无关的重复代码抽取出来，然后再嵌入到业务代码当中。常见的应用有：权限管理、日志、事务管理等。

实现方式

实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。Spring AOP实现用的是动态代理的方式。

### java加载器类型

#### 启动（Bootstrap）类加载器

启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，包含`/lib`

#### 扩展（Extension）类加载器
扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，包含`/lib/ext`

#### 系统（System）类加载器
也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader，`java.class.path`

#### 双亲委派模式工作原理
双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当由自己的父类加载器来进行加载。

####双亲委派模型的原因

因为如果用不同的加载器来加载同一个class文件，调用他们的equals方法，可能会得到无法确定的结果，因此需要双亲委派模型

#### 双亲委派模型的破坏

举个例子，driver接口定义在jdk中，对各个数据库厂商，他们都定义了自己的数据库连接类，需要数据库连接的时候，就需要由子类加载器来加载，此时就需要破坏双亲委派模型。打破方法是：重写classloader的loadclass方法。

### classnotfoundError
什么时候会抛出classnotfoundException异常呢？

这涉及到底层的API。当程序试图使用class类中的forname方法、classloader类中的findsystemclass方法，classloader类中loadclass方法通过字符串名的形式加载此类时，会抛出该异常
解决方案

 1. 首先检查一下你的环境变量classpath的配置，看一看所需要的支持类库是否放在类路径里面
 2. 类名错了，在调用class类中的forname方法时会出异常，很明显，我的是在调用classloader的loadclass方法时出错

### NoSuchMethodError
在Java项目开发时一般会使用maven作为项目jar包依赖管理工具，但随着工程依赖的jar包越来越多，“jar包冲突”这个潜在隐患随时可能爆发出来。大部分情况下，我们都会见到“java.lang.NoSuchMethodError”异常信息，这种情况一般都是由于包冲突引起的。

### 垃圾回收器种类
Java有四种类型的垃圾回收器：

串行垃圾回收器（Serial Garbage Collector）
并行垃圾回收器（Parallel Garbage Collector）
并发标记扫描垃圾回收器（CMS Garbage Collector）
G1垃圾回收器（G1 Garbage Collector）

#### 红黑树定义

1. 结点是红色或黑色
2. 根结点始终是黑色
3. 叶子结点（NIL 结点）都是黑色
4. 红色结点的两个直接孩子结点都是黑色（即从叶子到根的所有路径上不存在两个连续的红色结点）
5. 从任一结点到每个叶子的所有简单路径都包含相同数目的黑色结点

#### 为什么hashmap线程不安全

两个不安全的要点：

1. put函数，两个线程同时put的时候，会丢失一个数据；

2. resize函数，大小超过阈值的时候，扩容，新建一个更大的数组，将原来的数据复制到新数组中。因为是数组中的元素是链表，复制之后顺序改变，而如果两个线程同时复制，那么将一会变正，一会变反，形成死锁。

#### 手写LRU算法(页面置换算法)

LRU（Least recently used，最近最少使用）

```java
import java.util.LinkedHashMap;

public class LRU<K, V> {
    private static final float hashLoadFactory = 0.75f;
    private LinkedHashMap<K, V> map;
    private int cacheSize;

    public LRU(int cacheSize) {
        this.cacheSize = cacheSize;
        int capicity = (int) Math.ceil(cacheSize / hashLoadFactory) + 1;
        this.map = new LinkedHashMap<K, V>(capicity, hashLoadFactory, true) {

            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > LRU.this.cacheSize;
            }
        };
    }

    public synchronized V get(K key) {
        return this.map.get(key);
    }

    public synchronized void put(K key, V value) {
        this.map.put(key, value);
    }

    public synchronized void clear() {
        this.map.clear();
    }

    public synchronized int size() {
        return this.map.size();
    }
}

```

#### 一致性hash

redis集群，假如现在有2000w条数据，你有8台服务器，组成组从复制（将主服务器数据复制到从服务器，所有增删改操作在主服务器，读操作在从服务器，这样能减轻主服务器压力，也只用给远端暴露从服务器，增强安全性）的四组(每组两台)，你通过hash算法，这样可以快速找到哪个数据存在哪个服务器上。

但是现在比如你多了一组服务器，原本的hash结果对4求余(hash(key)%4)，现在的hash结果对5求余，那所有数据的hash值都变了，全部要重新放一遍，效率很低。

这时就需要一致性hash算法，假设整个hash值空间为0-2^32-1，我将这个范围连成一个环。对每个主机hash后放到环上，一个元素该放到哪个主机，就是hash结果顺时针方向走过的第一个主机节点，如下图所示。

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326120000.png)

当新增一个节点比如Node X，假如增加到了B和C之间，那么受到影响的元素只有原先在C的元素

又比如C节点坏了，那么就把c节点所有元素复制到D就行了。如下图

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326120228.png)

一致性hash有个问题就是假如两个节点hash值在环上距离太近，那么会造成不平衡的问题。解决办法是增加虚拟节点，一个节点多次hash，放到环上，这样就消除了数据不平衡的问题。

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326120322.png)

#### 线程池参数

1. corePoolSize:核心线程数，值为每秒任务数\*每个任务耗时，设置为80%时间出现的任务书的值，比如每秒200~1000个任务，每个处理0.1秒，那么需要20~100个线程，核心线程数至少大于20，根据80%准则，设置为40

2. 队列长度：核心线程数/每个任务的时间*响应时间，例子中是40/0.1\*1=400，假设系统响应时间最多为1s

3. 最大线程数：（最大线程数-队列长度）\*每个线程花费时间，(1000-400)\*0.1=60

4. keepAliveTime:当负载降低时，如果一个空闲线程时间达到keepAliveTime，就退出

5. allowCoreThreadTimeout:默认不允许核心线程退出，设为true的时候可以退出

**线程池按以下方式执行任务**

1. 当线程数小于核心线程数时，创建线程。
2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
3. 当线程数大于等于核心线程数，且任务队列已满
   1. 若线程数小于最大线程数，创建线程
   2. 若线程数等于最大线程数，抛出异常，拒绝任务

#### hash冲突的解决办法

1. 开放地址法：按原始数据顺序计算hash值，如果某个位置算出来已经有值了，就向后找到第一个没有值的位置放这个值
   ![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190326154149.png)
2. 链地址法：数组每个位置存的都是链表，冲突的加入链表末尾
3. 再hash法：冲突就用新的hash函数计算，直到不冲突
4. 公共溢出区：如果溢出就放入公共溢出区

####CAS和ABA问题

CAS（compare and swap)：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。

解决方法：

AtomicStampedReference解决aba问题，不光比较值是否相同，还比较版本号是否相同

#### 数据库引擎

**Myiasm**

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(\*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

**Innodb**

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

**总结：**

1. innodb支持四种SQL隔离，ACID四种特性，支持事物和行级锁，对于大数据一般用innodb
2. Myiasm保存了行数，seleclt count(\*)的效率比较高，更新数据需要锁定整个表。如果大量读，也可以用myiasm

#### spring boot如何启动一个项目

```java
@SpringBootApplication
SpringApplication.run(SellApplicaiton.class,args)
```

#### aop底层实现

AOP思想的实现一般都是基于 **代理模式** ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，**JDK动态代理模式只能代理接口而不能代理类**。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。

- 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；
- 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。

#### 数据库分页

在mysql当中是用limit实现的，select * from table limit 0,10

#### 数据库索引失效

1. 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
2. 对于多列索引，不是使用的第一部分(第一个)，则不会使用索引
3. like查询是以%开头
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

#### redis分布式锁

通过redlock实现，先按顺序加锁，如果锁住的服务器已经超过一半，并且如果锁的持续时间超过加锁耗费的时间，那么锁就加成功了，否则依次释放所有的锁。

#### java获取系统时间

calendar库和date库

#### 时间的格式化方法

calendar库和date库，

格式化方法是simpledateFormat(format和parse函数)或者string.format("%tY")

```java
Date day=new Date();

SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);

Calendar c = Calendar.getInstance();//可以对每个时间域单独修改

int year = c.get(Calendar.YEAR);

```

#### 序列化反序列化

Java序列化是指把Java对象保存为二进制的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。

那么为什么需要序列化呢？

第一种情况是：对java对象持久化保存

第二种情况是：需要把Java对象通过网络进行传输的时候。

```java
FileOutputStream fos = new FileOutputStream("temp.out");
ObjectOutputStream oos = new ObjectOutputStream(fos);
TestObject testObject = new TestObject();
oos.writeObject(testObject);


FileInputStream fis = new FileInputStream("temp.out");
ObjectInputStream ois = new ObjectInputStream(fis);
TestObject deTest = (TestObject) ois.readObject();
System.out.println(deTest.testValue);

class TestObject implements Serializable {
}
```

#### 线程共享变量

因为java对共享变量的读写需要从主存中复制到工作内存中成为副本，更改之后再从工作内存复制到主存中，如果多个线程对共享变量进行更改，需要保证更改后及时更新到主存，其他线程能够及时从主存中读取新的变量值更新到工作内存中。这就要求可见性。实现方式有synchronized 和 volatile 以及 java.concurrent.automic

**volatile适用情况**

a.对变量的写入操作不依赖当前值

比如自增自减、number = number + 5等（不满足）

b.当前volatile变量不依赖于别的volatile变量

比如 volatile_var > volatile_var2这个不等式（不满足）

**volatile实现原理**

用单例模式，对应的汇编代码有一个lock 的add 0操作，对应的x86的操作者手册，有lock的汇编操作有两个：1.讲缓存数据写回到系统内存，2.当前写回操作会使其他内存中的对应地址无效。

**synchronized和volatile比较**

a. volatile不需要同步操作，所以效率更高，不会阻塞线程，但是适用情况比较窄

b. volatile读变量相当于加锁（即进入synchronized代码块），而写变量相当于解锁（退出synchronized代码块）

c. synchronized既能保证共享变量可见性，也可以保证锁内操作的原子性；volatile只能保证可见性

d. `volatile`关键字会禁止指令重排。`synchronized`关键字保证同一时刻只允许一条线程操作。



#### java内存模型

有一个主存，所有变量都要从主存里面复制到工作内存中使用，如果一个变量改了，那么要立刻刷新回主存中，让其他变量知道，这就是可见性。一个操作要么执行，要么不执行，这就是原子性。sychronized保证的是原子性和可见性，volatile只保证可见性，但禁止了指令重排。

#### Synchronized

synchronize关键字主要是用于解决多线程访问临界资源的同步性，保证被其修饰的代码块同时只有一个线程可以执行。早期版本synchronize关键字的monitor实现方式要用系统的mutex lock(互斥锁)实现，但是jdk6之后对其进行了优化，出现了自旋锁，偏向锁，轻量锁，重量锁等方法，效率提高

有三种使用方式：

1. 修饰实例方法：对实例加锁
2. 修饰静态方法：对类加锁
3. 修饰代码块：对指定对象加锁

#### synchronized 关键字的底层原理

1. 修饰代码块

   用的是monitorenter和monitorexit实现，计数器为0的时候，可以获取锁，获取之后计数器变为1，释放锁的时候计数器变为0。如果获取锁失败就阻塞等待。

2. 修饰方法

   用一个acc_synchronized标志，通过访问标志确定是否加锁。

#### Synchronized和ReentrantLock的区别

**① 两者都是可重入锁**

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

**② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API**

synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

**③ ReenTrantLock 比 synchronized 增加了一些高级功能**

相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：**①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）**

- **ReenTrantLock提供了一种能够中断等待锁的线程的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。** ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”** ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。

#### AQS底层原理

AQS：AbstractQueuedSynchronizer

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。

AQS的核心思想是如果请求一个共享资源，他是没有被占用的，就把请求资源这个线程设置为有效的工作线程。如果被占用，就加入一个CLH双端队列

AQS用一个state来表示同步状态，AQS用CAS对这个同步状态进行原子操作，为1表示被锁定，为0表示空闲。

AQS有两种资源访问的形式，一种是独占的，一种是共享的(信号量，倒计时器，循环栅栏)

1. **Semaphore(信号量)-允许多个线程同时访问**

   设置一个许可证数量，如果一个线程开始执行时，要先acquire一个许可证，在许可证数量大于0的情况下，可以直接获取成功，否则获取失败被阻塞。线程执行完之后会释放一个许可，供后面到来的线程使用。

   场景：工厂有5台机器，8个工人，只有有机器空闲的时候，空闲工人才能上机。

2. **CountDwonLatch（倒计时器）**

   倒计时器是一开始设置为n，n就是线程的数量，每执行完一个线程，调用await方法，使倒计时器值减1，直到倒计时器减为0，所有线程执行完毕。倒计时器是一次性的，无法重用。

   场景：马拉松比赛，排名。要等所有人跑完才能计算排名。

3. **CyclicBarrier(循环栅栏)**

   循环栅栏，顾名思义，就是一个可以循环使用的栅栏，栅栏是什么意思呢，就是等待一定数量的线程到达栅栏，然后一起执行。每个线程用await方法告诉循环栅栏自己到达栅栏了。

   主要应用场景是：十个人约着去吃饭，等大家都到了才能出发。与倒计时器的区别主要是这个栅栏可以重置留着下次用。

#### 加锁会带来哪些性能问题。如何解决？

缩小锁的范围，锁住变量而不是方法。使用java.util.concurrent下面的并发容器。

#### NginX如何做负载均衡、常见的负载均衡算法有哪些

Nginx的upstream目前支持的6种方式的分配，分别是：轮询策略，权重轮询策略，ip_hash策略，fair策略，url_hash策略，sticky策略等。

轮询就是来一个请求就按顺序分给多台服务器

权重轮询就是给每个服务器一个权重，请求按权重的比例为概率分给服务器

ip_hash是根据ip的hash值选择服务器

url_hash就是根据urlhash值选择服务器

fair就是挑选目前负载最小的服务器

sticky就是一个客户端只与一个后端服务器交互，直到断开之后再选一个服务器

#### 出现 OOM 后你会怎么排查问题？

1. 堆空间大小不足
2. 内存泄漏：比如hashmap每次插入数据，数据重写了hashcode方法，但是数据没有重写equals方法

#### 操作系统的内存管理机制

虚拟内存，将物理地址映射成逻辑地址，通过页表查询，当程序需要的虚拟内存不在内存中时，产生缺页中断，通过页表去内存中找到需要的逻辑地址对应的物理地址，如果内存满了就用页面置换算法（最佳，最久未使用，最近未使用，先进先出，第二次机会，时钟算法）。

#### 说下你对线程安全的理解

当多个线程需要访问同一个互斥资源的时候，就会产生线程安全问题。

#### 哈夫曼编码是怎么回事

哈弗曼编码是一种无损压缩编码技术，出现次数多的内容用较短的编码，出现次数少的用较长的编码。

假如我有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3，如图：

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190327215224.png)
　　虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190327215238.png)

再依次建立哈夫曼树，如下图：

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190327215252.png)

其中各个权值替换对应的字符即为下图：

![](https://github-blog-1255346696.cos.ap-beijing.myqcloud.com/20190327215308.png)

所以各字符对应的编码为：A->11,B->10,C->00,D->011,E->010

#### 直接调用线程的start和run有什么区别

start是真正的多线程运行，run方法是按顺序执行的。

#### 线程池的好处

- **降低资源消耗。** 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度。** 当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性。** 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

#### 泛型怎么实现的

​       Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。

####  常见hash算法

md4,md5,sha1

#### Object 类方法

getClass，hashcode，equals，clone，toString，notify，notifyAll，wait，finalize

#### String为啥不可变

string里面放的是一个char的数组，定义是final的，并且string本身也是final的，所以string是不可变的

string设计为不可变是为了线程安全，同时string通常被用于hashmap的key，可变容易引起冲突

#### java浮点数精度问题

java会出现`double result = 1.0 - 0.9;`result的结果是0.09999999999999998的情况，要理解这个问题，就要看10进制数是如何存入计算机变为二进制的，比如11，每次除以2，直到为0，所有计算过程中的余数组成它的二进制表示；而十进制的小数，小数部分是每次\*2，然后取整数部分，直到没有小数为止，比如0.9一直乘以2，永远无法结束，就循环了，因此精度就不准了。

解决方法是用bigDecimal类型。

#### java跳出多重循环

三种方法：意识lable标签，用break label的方法跳出，还有一种是写到函数里面，用return跳出；用一个flag标志，每次循环要判断flag的值。

#### 正则表达式原理

nfa（Nondeterministic Finite Automata非确定有穷）自动机

#### i++线程安全吗

不安全，比如多个线程同时执行i++，那么他们相加的结果可能会重复，比如两个线程，一个执行1000次i++，结果肯定小于2000，同时读到0，同时+1，同时返回1，本来预期结果是2。解决方法是加入原子操作，或者用synchronize关键字修饰

#### collection和collections的区别

collection是一个集合接口，提供了一大堆通用方法，java中常用的集合都是从collection接口实现的。

collections是一个工具类，提供了很多对集合的操作方法，比如排序之类的。

#### java线程同步的几种方式

1. synchronized修饰方法
2. synchronized同步代码块
3. 用volatile实现
4. 可重入锁，reentreantlock
5. 局部变量：threadLocal

#### 生产者-消费者模型

- 生产者持续生产，直到缓冲区满，阻塞；缓冲区不满后，继续生产
- 消费者持续消费，直到缓冲区空，阻塞；缓冲区不空后，继续消费
- 生产者可以有多个，消费者也可以有多个

可通过如下条件验证模型实现的正确性：

- 同一产品的消费行为一定发生在生产行为之后
- 任意时刻，缓冲区大小不小于0，不大于限制容量

```java
public class BlockingQueueModel implements Model {
  private final BlockingQueue<Task> queue;
  private final AtomicInteger increTaskNo = new AtomicInteger(0);
  public BlockingQueueModel(int cap) {
    // LinkedBlockingQueue 的队列是 lazy-init 的，但 ArrayBlockingQueue 在创建时就已经 init
    this.queue = new LinkedBlockingQueue<>(cap);
  }
  @Override
  public Runnable newRunnableConsumer() {
    return new ConsumerImpl();
  }
  @Override
  public Runnable newRunnableProducer() {
    return new ProducerImpl();
  }
  private class ConsumerImpl extends AbstractConsumer implements Consumer, Runnable {
    @Override
    public void consume() throws InterruptedException {
      Task task = queue.take();
      // 固定时间范围的消费，模拟相对稳定的服务器处理过程
      Thread.sleep(500 + (long) (Math.random() * 500));
      System.out.println("consume: " + task.no);
    }
  }
  private class ProducerImpl extends AbstractProducer implements Producer, Runnable {
    @Override
    public void produce() throws InterruptedException {
      // 不定期生产，模拟随机的用户请求
      Thread.sleep((long) (Math.random() * 1000));
      Task task = new Task(increTaskNo.getAndIncrement());
      queue.put(task);
      System.out.println("produce: " + task.no);
    }
  }
  public static void main(String[] args) {
    Model model = new BlockingQueueModel(3);
    for (int i = 0; i < 2; i++) {
      new Thread(model.newRunnableConsumer()).start();
    }
    for (int i = 0; i < 5; i++) {
      new Thread(model.newRunnableProducer()).start();
    }
  }
}
```

#### 为什么不推荐使用suspend和stop

stop会解出线程获得的所有锁，线程所有运行的内容立即停止。

suspend容易造成死锁，调用的时候，suspend会停下来，但仍获得之前的锁，其他线程无法访问锁定的资源，除非线程被恢复。

#### 非公平锁和公平锁在reetrantlock里的实现

公平锁就是按先来后到的顺序执行线程，非公平锁是按优先级执行线程。在reetrantlock里面，实现公平锁是tryAcquire，如果发现当前要lock的线程是阻塞队列中的头元素或者阻塞队列为空，那么就获取锁成功，否则按照fifo的原则加入阻塞队列中。

非公平锁就是每个线程获取锁的概率是一样的，这样减少了jvm在线程调度的开销，实际调用的是sync的nofairtryAcquire方法，获取当前线程，查看aqs维护的锁的状态，如果状态为0，则经aqs的setStatus从0设为1。

#### LongAdder与AtomicLong区别

LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。 

缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。

#### 聚集索引与非聚集索引

聚集索引：**叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引**

非聚集索引：MyISAM的**B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址**。